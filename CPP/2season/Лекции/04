# Продолжение контейнеров 

vector<bool>

Вот это: bool *p = &v[0] не сработает

v[i] = true мы хотим что бы это работало хотим чтобы v[i] было lvalue
но так мы не можем сделатть так: 
bool & operator[](int i) 
мы возвращаем прокси обьект: 
proxyobj operator[](int)
он хранит в себе индекс и указатлеь на массив
у него определны два оператора 
bool() - приведение к bool 
operator=(bool) -присваивание bool

vector<bool> -оптимизация памяти, ухудшение времени работы ну чего и следовало ожидать

права работают на уровне разрешения имен


если будет так: 
template< >
vector<bool> {
private:
    struct proxy;
}


То что он в привате значит что  не могу написать:
vector<bool>::proxy 


Ассоциативные контейнеры!!!!! 
приступим!


set, multiset : <set>
map, multimap : <map>


Принцип begin Первый а end следующий за последним позваляет задавать пустую последовательность: begin == end

set  метод insert возращает два значения iterator и булевое значение был ли добавлен элемент в set
обычно в set исплоьзуется красно-черное дерево но в стандарте не определено.

Есть небольшая неприятность с удалением 


map/ multimap это отображение а не какая нибудь карта!:)

map - отображение
map - сортирует по ключу
map.insert(std::pair<string , int>("vasia", 14)) пайр
или 
map<string, int >::value_type
std::make_pair("vasia", 14);

возращает итератор и 

есть еще однин способ добавления: 
m["vasia"] = 123456
работает так ищет элемент васю если нет то создает элемент и второе значение инициализирует дефолтным значением по началу
если нет дефолтоного  конструктора то не сработает
так же это плохо еслид дефолнтый конструктор слишком сложен
быстродействие: кто быстрее:
copy constractor против default constractor & оператор причваивания

квадратные скобки[] не работают с multimap и Константым map'ом

теперь об итераторах
вывод 

можно ли по итератору изменить значение? 
Ан нет. итератор возращается на пару где первый элемент конст
в сет все элементы нельзя менят
ну это же понятно иначе iterator девалюируется

size Работает: за O(N) N- число элементов

lower_bound укзываать на первый из искомых элементов
upper_bound на следующий за последним элементом
equal_range возращает два указателя как от ловер и аппер
если не найдено то оба указателя указывают на одно и тоже место.
инсерт по итератору добавит перед первым значением на которое указывает итератор
вообще правильнее думать что итераторы указывают на промежутки между элементами их ведь (n+1)

!(x<y)&& !(y<x) то-> x == y это проверка корректности оператора меньше.
какие могут быть спроблемы:

1. класс не наш                                 
    решение: просто внешний оператор меньше 
2. оператор < работает не как меньше            
    в общем не правильное решение: писать свой класс
    правильное решение: 
        внутри map и set используется класс less  который имеет один оператор 
        bool oprerator()(T const &a, T const &b) const
        внутри элементы сравниваются так: if(less<T>()(x, y))
        стандарт запрешает писать что-то в стд
        но не запрещает специализировать шаблоны из стд
        еще вариант вам нужно несколько способов сравнения
        map<string, int, cmp = less<> >                                                
        компаратор можем передать еще и в констукторе 
о функторах у них могут быть данные тада. ну естественно

еще тонкость
у метода map.erase Нет возращаемого значения

это обходится двумя способами: 
1.microsoft way Возращаем указатель на что-то
2. используем такую приколюху: m.erase(it++); он передвинется на следующий до того как удалится текущий



