
Лекция 3 STL Последовательные контейнеры

реализация stl для GCC, CL, Intel, stlPort
stlPort bonuses переносима на все платформы. быстрее развивается

stl: контейнеры  итераторы(адаптеры) и алгоритмы



требования к контейнерам:
1.Assignable (оператор присваивания)
2.Copyconstractable (конструктор копирования)
3.Естественная семантика операции
4.открытый деструктор



два способа перебора контейнеров:
по индексу по указателю
указатель: 
for(int * p = ms; p != m+100; ++p) {
    *p = 10;
}

стандартизированный синтаксис контейнера это перебор по казателю
Iterator синтаксически ведет себя как указатель

унифицированный код по сути
for(list<int>::iterator it = l.begin(); it!=l.end(); ++it) {
    cout<< *it;
}

 vector          
---------------
    Раширение
    массивов

    быстрые опрерации:
        обращение по индексу    О(1)
        добавдение в конец      О(1)
        удаление в конец        О(1)
        size()
    
    у вектора есть два размера это Capasity и size
    1ое размер буфера
    2ое сколько там элеменнтов лежит
        зачем знать капасити 
        перевыделения памяти можно зибежать при помощи функции reserve(n) она выделит буфер как минимум размера n
        resize(n) двойная операция там будет уже лежать n элементов.
    как очистить буфер у вектора clear Может быть эвивалентен resize(0)
    пример удаления: 
            resize(100000);                
            ms.clear(); //вызовется
            //капасити будет >= 100000
            //как очистить капасити?
            vector<int>().swap(ms); //Поменяли содержимое обьектов получили в ms ноль элементов а для временного вектора вызывается деструктор.
            vector<int>(ms).swap(ms);// получаем что капасити нового обьекта будет >= ms.size() тк при копировании капасити не копируется
    насчет совместимости:
        есть функция f(int * m, size_t size);
        тогда можно передать &ms[0] указатель на первый элемент а он хранится одним 


        
    
deque         
--------------
    список массивов 
    двусвязный список массивов  
    с плавающим началом и концом
    еще есть некоторая таблица массивов для того чтобы произвольный доступ имел амортизированное время доступа.

    быстрые операции:
        взятие по индексу
        push_back()
        pop_back()
        push_front()
        pop_back()
        size()
    у дека нет capasity!
    удаление в начало и конец быстрое
    все бесхитростно

list
--------------
    двусвязный 
    список 
    
    быстрые операции: 
        insert Если есть элемент
        erase        
        либо size либо трехытераторный инсерт работают быстро.
        трехитераторный инсерт это когда часть одного листа вырезается и вставлется в другой
            но при этом мы не знаем размера этого куска потому не можем обновить быстро сайз
            так что в основном быстро работает size()
    
    list<int> l();
    нет ресайза
    Есть push_back()
    есть push_front()
    добавление удаление требуется итератор
            
    
string
--------------
    будем считать
    как вектор
    
    быстрые операции: 
        аналогично вектору
    поддерживает многие операции вектора
    время жизни: s.c_str() до первой не константной операцие со строкой s
    копирование строк: g = s; Копирование строки вместе с полями. вроде как


for(c::iterator it = c.begin(); it != c.end(); ++it ) {
    if(*it == 0) {        
        it = c.erase(it); //при изменении контейнера кстати все итераторы инвалидируются. но ты же это и так знаешь. и пишешь дурацкий коммент
    else    
        ++it;
    }
}

----------------------

анализируете все что вам нужно 
и выбираете вектор.






