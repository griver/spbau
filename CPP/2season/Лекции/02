Лекция 02
1. template < class T > type
2. template <template <class> class T>
во втором можно подставлять шаблон


3. В качестве параметра шаблона можно указывать любой целочисленный тип
    template <int N> 
    N - это число известеное на момент компиляции 
    Пример: 
        template <int N, int M>
            struct Vect2D
            Vect1D<N*M> impl;
   С вещественными типами так делать нельзя. Нет однозначности 1/7+6/7 совсем не обязательно равно 1.(разные погрешности, разные вычисления)  

4. Указатели и ссылки могут быть параметрами шаблонов. Но так же должны быть известны на моменты компиляции. 
   Указатели и ссылки должны быть со внешней линковкой. 
    ЭКСКУРС В ИСТОРИЮ: cpp--|препроцессор|--> {cpp без макросов} ---->{ASM} ----> {OBJ} --|linking: разрешает ссылки в обьектниках|-->{exe}
    в общем в шаблон может быть передана только ссылка/указатель на какую-нибуть глобальную переменную
    Пример использования: указатель на менеджер памяти например.  
    вместо указателя здесь может быть ссылка
    
5. Указатель на другие сущности (функцию, методы, поля): для общего развития


ВТОРАЯ ЧАСТЬ ЛЕКЦИИ: СПАЦИАЛИЗАЦИЯ ШАБЛОНОВ

шаблоны можно специализировать для конкретных значений шаблонных парметров

пример: контейнер который хранить биты
    если заведем bool m[100] : Его размер будет точно не 100 бит а например 100 байт, может 400( в стандарте не написано)
    мы теряем память
    написали шаблонный тип вектор: 
    template <class T>
    struct Array {
        T* data;    
    }
    если сделаю Array<bool> то он выведет bool* data и эта штука будет в байтах.
    Но можно сделать реализацию для конкретного отдельного значения параметра шаблона:
    template<>
    struct Array<bool> {
        int* data;    
    }
    причем эта реализация вообще не обязанна быть похожа на другие реализации для этого шаблона тк это разные типы
    специализируем функцию:
    template<class T>
    void reverse(Array<T> a){}
    
    template<>
    void reverse(Array<bool> ){};
    функции специализированные не учитываются в момент перегрузки.
        если уже выбранна функция шаблона такого то тогда уже выбирается среди специализаций

 Фаблонные функции имеют меньший приоритет чем не шаблонные.

А есть понятие частичной специализации. Когда мы подставляем не все параметры. Шаблон остаётся шаблоном.
template <class T >
struct Array;


template <class U>
struct Array<U*>

это некоторое сужение если T=U* то вызовется второе


при ЧС даже не обязательно совпадения количиства параметров шаблона:

template <class A, class B>
stuct Array<Pair<A,B> >   
 
это так же специализация первого шаблона

а)специализация и частичная специализация различаются в следующем:
был шаблон и специализация то тогда специализация это уже обычный класс функция и тд.

б) если был шаблон и частичная специализация
то это всеравно шаблон и его всеравно нужно инстанцировать.

условие: частичная специализация может быть только для классов
но не для функции. 
ПОЧЕМУ?? например вопрос для T и U*
причина такая у обьектов нет механизмов перегрузки. для функций есть механизм перегрузки. Так зачем морочиться с шаблонами!!
вот например: 
template <class T>
void reverse(Array<T> a);
template <class T>
void reverse(Array<T*> a);
это будет перегрузка функции а не ЧС. 

ПАРОЧКА ЗАМЕЧАНИЙ О ШАБЛОНАХ:
шаблоны функции против шаблонов классов
Ш.Ф                                 Ш.К
вывод парметров                     частичная специализация
(не пишем явно ш.)

парам-ов                            сециализация

пергрузка                           значения по умолчанию



template <class T, class A= allocator<T> >
в функции нет значений по умолчанию



2 замечания в конце

1. template < class T>
void f(Array<T> a)
Можно попытаться обратится к именам которые зависят от параметра шаблонам.
компилятору нужно указать что мы обращаетмя с типу. по этому нужно перед этим нужно написать ключивое слово typename

typename Array<T>::allocator

избегать циклической зависимости вида
